\chapter*{Introdução}
\label{cha:introducao}
\addcontentsline{toc}{chapter}{Introdução}
Atualmente com o crescimento e popularização dos computadores, vários sistemas que anteriormente eram controlados por humanos, tornaram-se automatizados, ou seja controlados por \textit{software}, isto permitiu criar sistemas mais fiáveis e eficientes, na medida em que foi reduzida a intervenção humana, e consequentemente os erros associados a esta. \par
Contudo existem vários tipos de sistemas dependem inteiramente do \textit{software} que os suporta e que têm a necessidade de continuarem operacionais mesmo quando existe algum evento de falha. Caso o sistema não consiga tratar e recuperar alguma falha ou contenha algum defeito, podem resultar consequências graves como por exemplo: um desastre ambiental, estragos em equipamentos dispendiosos ou mesmo a morte de pessoas, estes sistemas são designados de sistemas criticos. \par
Uma forma melhorar as hipóteses de um sistema critico recuperar de falhas, é ter diversidade no design e na arquitetura, tal facto vai permiter obter alguma redundância o que torna o software mais fiável. Esta técnica é designada \textit{n-version programming}, de uma forma muito sintética são criadas várias variantes do mesmo software criadas geralmente por equipas diferentes que, quando operacionais, vão partilhar os \textit{inputs} e gerar cada uma os seus \textit{outputs}. De seguida e como esses outputs podem conter resultados diferentes, é utilizado um outro módulo de \textit{software} que tem como função receber todos os \textit{outputs} das variantes e decidir um \textit{output} baseado nas inputs das variantes. \par
É de salientar que o votador é um \textit{single point of failure}, porque á semelhança das variantes não contem diversidade, contudo este deve ser o mais robusto possível e o mais \textit{fault free} possível. Para preencher estes requisitos o votador deve ter um implementação simples e minimalista de modo a evitar erros de programação. \par
É importante salientar que esta técnica apesar de esta técnica poder evitar erros semelhantes entre as implementações, porém a realização de cada versão aumenta bastante os custo de produção de software nunca garantindo resultados correctos.
